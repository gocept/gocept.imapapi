=============
IMAP messages
=============

IMAP messages provide a convenient way to access information from a mail
message. They are roughly based on the structures that Python's email module
provides but are optimized to avoid loading too much data at once and to
provide very convenient access.

Messages are retrieved from folders which are IMessageContainers:

>>> from gocept.imapapi.account import Account
>>> account = Account('localhost', 10143, 'test', 'bsdf')
>>> INBOX = account.folders['INBOX']
>>> INBOX.name
'INBOX'
>>> from gocept.imapapi.interfaces import IMessageContainer
>>> IMessageContainer.providedBy(INBOX)
True

Note that the account itself is not a message container. It only contains
folders, not messages:

>>> IMessageContainer.providedBy(account)
False

Let's get a message now:

>>> message = INBOX.messages.values()[0]
>>> message
<gocept.imapapi.message.Message object 'INBOX/...' at 0x2312872>


Headers
=======

Headers can be accessed using the dictionary API on the message. Headers are
decoded into unicode automatically:

>>> message.headers['X-IMAPAPI-Test']
u'1'
>>> message.headers['X-Correct-Encoding-Header']
u'Text \xfc'

Invalid encodings will end in unicode strings anyway but with replaced
characters as a hint:

>>> message.headers['X-Unknown-Encoding-Header']
u'Text \ufffd\ufffd'
>>> message.headers['X-Wrong-Encoding-Header']
u'Text \ufffd\ufffd'
>>> message.headers['X-No-Encoding-Header']
u'Text \ufffd or not'

Other popular headers like From, Date and Subject can be accessed by using the
dictionary API, too. They are also decoded into unicode automatically:

>>> message.headers['From']
u'test@localhost'
>>> message.headers['Date']
u'02-Jul-2008 03:05:00 +0200'
>>> message.headers['Subject']
u'Mail 1'


Raw
===

The message itself can be accessed in the raw form including all headers,
parts etc. This does not perform any mangling, decoding or other function that
would change the representation from what is stored on the server:

>>> message.raw
'From: test@localhost\r\nX-IMAPAPI-Test: 1\r\nX-No-Encoding-Header: Text \xfc or not\r\nX-Wrong-Encoding-Header: =?ascii?q?Text_=C3=BC?=\r\nX-Unknown-Encoding-Header: =?foobarschnappeldiwutz?q?Text_=C3=BC?=\r\nX-Correct-Encoding-Header: =?utf-8?q?Text_=C3=BC?=\r\nDate: 02-Jul-2008 03:05:00 +0200\r\nSubject: Mail 1\r\n\r\nEverything is ok!'

Plain text
----------

The message body itself can also be retrieved in a plain text version (which
might include encoded mime parts):

>>> print message.text
Everything is ok!


Message body parts
==================

Message body parts represent mime sub-structures and are accessible through
nested lists using the `body` of a message and the `parts` attribute on each
body part:

>>> message = INBOX.messages.values()[1]
>>> part = message.body
>>> part
<gocept.imapapi.message.BodyPart object at 0x2428811>

A body part is similar to a message in that it has headers and a body which
can be fetched:

>>> part['content_type']
'multipart/alternative'
>>> part.fetch()
'To: Thomas Lotze <tl@gocept.com>...Everything is ok!\r\n  </body>\r\n</html>\r\n'


Header access on body parts
---------------------------

Body parts implement a partial dictionary interface to access headers.
Upper-/lowercase is normalized automatically:

>>> 'content_type' in part
True
>>> part['content_type']
'multipart/alternative'

XXX Why is this 'content_type' instead of 'content-type' and why don't we
provide normalized access?
XXX>>> 'Content_Type' in part
XXXTrue
XXX>>> part['Content_Type']
XXX'multipart/alternative'


Accessing parts using the Content-ID header
-------------------------------------------

Body parts can carry a `Content-ID` header (or `cid` for short) which is
globally unique and can be used to find a nested body part somewhere inside a
body part.

>>> message = INBOX.messages.values()[3]
>>> message.headers['Subject']
u'11 - AppleMail, Complex HTML with many images'

>>> part1 = message.body.by_cid('919A8163-52C0-4CE3-B45C-F05A1AE2FC3D/top.jpg')
>>> part1['id']
'<919A8163-52C0-4CE3-B45C-F05A1AE2FC3D/top.jpg>'
>>> part1['content_type']
'image/jpeg'
>>> part1['size']
27412

>>> part2 = message.body.by_cid('919A8163-52C0-4CE3-B45C-F05A1AE2FC3D/bottom.jpg')
>>> part2['id']
'<919A8163-52C0-4CE3-B45C-F05A1AE2FC3D/bottom.jpg>'
>>> part2['content_type']
'image/jpeg'
>>> part2['size']
19046


Multipart/alternative
---------------------

Messages with the type ``multipart-alternative`` contain several parts with
the same content in different types (e.g. plain text and html). The mailer
itself chooses the proper part and displays it:

>>> message = INBOX.messages.values()[1]
>>> message.body
<gocept.imapapi.message.BodyPart object at 0x2428811>
>>> message.body['content_type']
'multipart/alternative'

This test message contains of two parts. One contains plain text, the other one
html quoted text:

>>> from pprint import pprint
>>> parts = message.body.parts
>>> pprint(parts)
[<gocept.imapapi.message.BodyPart object at 0x2428819>,
 <gocept.imapapi.message.BodyPart object at 0x2428212>]
>>> print parts[0]['content_type']
text/plain
>>> print parts[1]['content_type']
text/html

The parts content can be retrieved with the ``fetch`` method:

>>> print parts[0].fetch()
Everything is ok!

>>> print parts[1].fetch()
<html>
  <head>
    <title>Mail 2</title>
  </head>
  <body>
    Everything is ok!
  </body>
</html>

Multipart/mixed
---------------

Messages with the type ``multipart-mixed`` contain several parts with
differnt content (e.g. plain text, images, pdf files). The mailer
itself displays all parts inline or as an attachment:

>>> message = INBOX.messages.values()[2]
>>> message.body
<gocept.imapapi.message.BodyPart object at 0x2428811>
>>> message.body['content_type']
'multipart/mixed'

This testmessage contains of two parts. One part contains plain text, the
other one an image file:

>>> from pprint import pprint
>>> parts = message.body.parts
>>> pprint(parts)
[<gocept.imapapi.message.BodyPart object at 0x2428819>,
 <gocept.imapapi.message.BodyPart object at 0x2428212>]
>>> print parts[0]['content_type']
text/plain
>>> print parts[1]['content_type']
image/jpeg

The parts content can be retrieved with the ``fetch`` method:

>>> print parts[0].fetch()
Everything is ok!

>>> parts[1].fetch()
'\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01\x02\x00\x00d\x00d\x00\x00\xff\xec\x00\x11Ducky\x00\x01\x00\x04\x00\x00\x00H\x00\x00\xff\xe2\x058ICC_PROFILE\x00\x01\x01\x00\x00\x05(appl\x02 \x00\x00mntrRGB XYZ \x07\xd2\x00\x05\x00\r\x00\x0c\x00\x00\x00\x00acspAPPL\x00\x00\x00\x00appl\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\xf6\xd6\x00\x01\x00\x00\x00\x00\xd3-appl\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\rrXYZ\x00\x00\x01 \x00\x00\x00\x14gXYZ\x00\x00\x014\x00\x00\x00\x14bXYZ\x00\x00\x01H\x00\x00\x00\x14wtpt\x00\x00\x01\\\x00\x00\x00\x14chad\x00\x00\x01p\x00\x00\x00,rTRC\x00\x00\x01\x9c\x00\x00\x00\x0egTRC\x00\x00\x01\x9c\x00\x00\x00\x0ebTRC\x00\x00\x01\x9c\x00\x00\x00\x0edesc\x00\x00\x01\xac\x00\x00\x00?cprt\x00\x00\x02T\x00\x00\x00Hvcgt\x00\x00\x01\xec\x00\x00\x000ndin\x00\x00\x02\x1c\x00\x00\x008dscm\x00\x00\x02\x9c\x00K\x04g[q\xd3\xd3\t\\\x96\xa4\x91DH\x92\xfck\x9b\x03\xab\xd1\x9cS\xef\x8f\xa8`\xd1rI-\xfcf\xb2\x99\xcb\xf3i\xa2\xc60\xa4\xf6G2D\x96\'\xdfMB\xd2\xe3\xc1\x0e\xdf^\x9a;$=/u\x0fZ\xeb\xb3\x99}\xf6Q\xf9\x11\x18\x94A<z"\xf6\xf5\xfd\xa2\x020E\x8b\xe3|\x81\xe7\xd0\xe7\x93\x9bmO\x95\xc0p\x15}\x8dL|C).\xf67QbK\xbc\xe3q\x82dG\x80\xa1oDS`\xbf`\x1c\xbf4ZB\x9e\xe8x6^\x88\xcf\xa1\x8ba\xba\xb4\x96\xfb\xf88\x15M\xdb\x00\x00\x00\x00\x00\x00'
