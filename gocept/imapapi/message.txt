=============
IMAP messages
=============

IMAP messages provide a convenient way to access information from a mail
message. They are roughly based on the structures that Python's email module
provides but are optimized to avoid loading too much data at once and to
provide very convenient access.

Messages are retrieved from folders which are IMessageContainers:

>>> from gocept.imapapi.account import Account
>>> account = Account('localhost', 10143, 'test', 'bsdf')
>>> INBOX = account.folders['INBOX']
>>> INBOX.name
'INBOX'
>>> from gocept.imapapi.interfaces import IMessageContainer
>>> IMessageContainer.providedBy(INBOX)
True

Note that the account itself is not a message container. It only contains
folders, not messages:

>>> IMessageContainer.providedBy(account)
False

Let's get a message now:

>>> message = INBOX.messages.values()[0]
>>> message
<gocept.imapapi.message.Message object 'INBOX/...' at 0x2312872>


Headers
=======

Headers can be accessed using the dictionary API on the message. Headers are
decoded into unicode automatically:

>>> message.headers['X-IMAPAPI-Test']
u'1'
>>> message.headers['X-Correct-Encoding-Header']
u'Text \xfc'

Invalid encodings will end in unicode strings anyway but with replaced
characters as a hint:

>>> message.headers['X-Unknown-Encoding-Header']
u'Text \ufffd\ufffd'
>>> message.headers['X-Wrong-Encoding-Header']
u'Text \ufffd\ufffd'
>>> message.headers['X-No-Encoding-Header']
u'Text \ufffd or not'

Other popular headers like From, Date and Subject can be accessed by using the
dictionary API, too. They are also decoded into unicode automatically:

>>> message.headers['From']
u'test@localhost'
>>> message.headers['Date']
u'02-Jul-2008 03:05:00 +0200'
>>> message.headers['Subject']
u'Mail 1'


Raw
===

The message itself can be accessed in the raw form including all headers,
parts etc. This does not perform any mangling, decoding or other function that
would change the representation from what is stored on the server:

>>> message.raw
'From: test@localhost\r\nX-IMAPAPI-Test: 1\r\nX-No-Encoding-Header: Text \xfc or not\r\nX-Wrong-Encoding-Header: =?ascii?q?Text_=C3=BC?=\r\nX-Unknown-Encoding-Header: =?foobarschnappeldiwutz?q?Text_=C3=BC?=\r\nX-Correct-Encoding-Header: =?utf-8?q?Text_=C3=BC?=\r\nDate: 02-Jul-2008 03:05:00 +0200\r\nSubject: Mail 1\r\n\r\nEverything is ok!'


Message body
============

Plain text
----------

The message body itself can also be retrieved in a plain text version (which
might include encoded mime parts):

>>> print message.text
Everything is ok!

Multipart/alternative
---------------------

Messages with the type ``multipart-alternative`` contain several parts with
the same content in differnt types (e.g. plain text and html). The mailer
itself chooses the proper part and displays it:

>>> message = INBOX.messages.values()[1]
>>> message.body
<gocept.imapapi.message.BodyPart object at 0x2428811>
>>> message.body['content_type']
'multipart/alternative'

This testmessage contains of two parts. One contains plain text, the other one
html quoted text:

>>> from pprint import pprint
>>> parts = message.body.parts
>>> pprint(parts)
[<gocept.imapapi.message.BodyPart object at 0x2428819>,
 <gocept.imapapi.message.BodyPart object at 0x2428212>]
>>> print parts[0]['content_type']
text/plain
>>> print parts[1]['content_type']
text/html

The parts content can be retrieved with the ``fetch`` method:

>>> print parts[0].fetch()
Everything is ok!

>>> print parts[1].fetch()
<html>
  <head>
    <title>Mail 2</title>
  </head>
  <body>
    Everything is ok!
  </body>
</html>

Multipart/mixed
---------------

Messages with the type ``multipart-mixed`` contain several parts with
differnt content (e.g. plain text, images, pdf files). The mailer
itself displays all parts inline or as an attachment:

>>> message = INBOX.messages.values()[2]
>>> message.body
<gocept.imapapi.message.BodyPart object at 0x2428811>
>>> message.body['content_type']
'multipart/mixed'

This testmessage contains of two parts. One part contains plain text, the
other one an image file:

>>> from pprint import pprint
>>> parts = message.body.parts
>>> pprint(parts)
[<gocept.imapapi.message.BodyPart object at 0x2428819>,
 <gocept.imapapi.message.BodyPart object at 0x2428212>]
>>> print parts[0]['content_type']
text/plain
>>> print parts[1]['content_type']
image/jpeg

The parts content can be retrieved with the ``fetch`` method:

>>> print parts[0].fetch()
Everything is ok!

>>> parts[1].fetch()
'\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01\x02\x00\x00d\x00d\x00\x00\xff\xec\x00\x11Ducky\x00\x01\x00\x04\x00\x00\x00H\x00\x00\xff\xe2\x058ICC_PROFILE\x00\x01\x01\x00\x00\x05(appl\x02 \x00\x00mntrRGB XYZ \x07\xd2\x00\x05\x00\r\x00\x0c\x00\x00\x00\x00acspAPPL\x00\x00\x00\x00appl\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\xf6\xd6\x00\x01\x00\x00\x00\x00\xd3-appl\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\rrXYZ\x00\x00\x01 \x00\x00\x00\x14gXYZ\x00\x00\x014\x00\x00\x00\x14bXYZ\x00\x00\x01H\x00\x00\x00\x14wtpt\x00\x00\x01\\\x00\x00\x00\x14chad\x00\x00\x01p\x00\x00\x00,rTRC\x00\x00\x01\x9c\x00\x00\x00\x0egTRC\x00\x00\x01\x9c\x00\x00\x00\x0ebTRC\x00\x00\x01\x9c\x00\x00\x00\x0edesc\x00\x00\x01\xac\x00\x00\x00?cprt\x00\x00\x02T\x00\x00\x00Hvcgt\x00\x00\x01\xec\x00\x00\x000ndin\x00\x00\x02\x1c\x00\x00\x008dscm\x00\x00\x02\x9c\x00K\x04g[q\xd3\xd3\t\\\x96\xa4\x91DH\x92\xfck\x9b\x03\xab\xd1\x9cS\xef\x8f\xa8`\xd1rI-\xfcf\xb2\x99\xcb\xf3i\xa2\xc60\xa4\xf6G2D\x96\'\xdfMB\xd2\xe3\xc1\x0e\xdf^\x9a;$=/u\x0fZ\xeb\xb3\x99}\xf6Q\xf9\x11\x18\x94A<z"\xf6\xf5\xfd\xa2\x020E\x8b\xe3|\x81\xe7\xd0\xe7\x93\x9bmO\x95\xc0p\x15}\x8dL|C).\xf67QbK\xbc\xe3q\x82dG\x80\xa1oDS`\xbf`\x1c\xbf4ZB\x9e\xe8x6^\x88\xcf\xa1\x8ba\xba\xb4\x96\xfb\xf88\x15M\xdb\x00\x00\x00\x00\x00\x00'
